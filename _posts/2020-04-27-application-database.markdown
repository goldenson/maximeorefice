---
layout: post
title: "🐘 Application Database"
date: 2020-04-27
---

In this course we will look deeply into how `postgres` works.

## Day 1 - Indexing

### Installation

1. Install `postgres` from its [source](https://www.postgresql.org/download/)
2. Enable `debugging`
3. Add the `contrib` package
4. Authorize a new user: `sudo -u postgres -i`
5. Create a cluster: `initdb -E ETF8 --locale=en_US.utf8`
6. Connect to it with: `psql -h 127.0.0.1 -p 5432 -U postgres -d postgres`

### psql

The standard `postgres` client to interact with your cluster.

|           Command           | Explanation                          |
| :-------------------------: | :----------------------------------- |
|            `\?`             | List of psql commands                |
|            `\h`             | Display SQL commands                 |
|            `\l`             | List SQL tables                      |
|          `\d test`          | List the test table                  |
|        `TABLE test`         | runs a `SELECT *` on a given table;  |
|           `\dt+`            | Show me more on a table size         |
|          `timing`           | Set timing execution                 |
|            `\x`             | Sets expanded view                   |
| `SET enable_seqcran = off;` | Disable sequential scanning          |
|          `ANALYZE`          | Better approximation                 |
|           `\set`            | Display `pg` settings for the client |

### Indexes

#### btree indexes

This is the most common [index](https://www.postgresql.org/docs/12/indexes-types.html) used with simple data type that is **orderable**.

```sql
/* Create a new database */
CREATE DATABASE course;

/* Create a new table */
CREATE TABLE test (id bigint GENERATED ALWAYS AS IDENTITY NOT NULL, name text NOT NULL);

/* Insert a lot of data */
INSERT INTO test (name) VALUES ('max'), ('ore');
INSERT INTO test (name) SELECT name FROM test;

/* Create an index */
CREATE INDEX test_id_idx ON test (id);

/* Analyze what pg does */
postgres=# EXPLAIN SELECT * FROM test WHERE id = 42;
 Index Scan using test_id_idx on test  (cost=0.43..8.45 rows=1 width=12)
   Index Cond: (id = 42)
```

Those numbers are an approximation generated by `postgres`.

|    data     | Explanation                                    |
| :---------: | :--------------------------------------------- |
| `cost 0.43` | time to find the data                          |
| `cost 8.45` | average time to perform the entire SQL request |
|   `rows`    | how many rows will be returned?                |

#### More

|      Index type       | SQL                                                             | How/When?                                             |
| :-------------------: | :-------------------------------------------------------------- | ----------------------------------------------------- |
|  `Conditional index`  | `CREATE INDEX ON test (name) WHERE name NOT IN ('max', 'ore');` | If more constraint                                    |
| `Multicolumn indexes` | `CREATE INDEX ON test (id, name);`                              | Pick columns where you have an `EQUAL` operator.      |
|     `Expressions`     | `CREATE INDEX ON test (upper(name));`                           |                                                       |
|     `Extensions`      | `CREATE EXTENSION citext;`                                      | Dealing with case sensitive                           |
|      `Operators`      | `CREATE INDEX ON test (name text_pattern_ops);`                 | Useful when index required with a `LIKE` (ex: "max%") |
|     `Exclusions`      | `CREATE INDEX EXCLUDE USING gist(res WITH &&);`                 |                                                       |

#### gin indexes

Use `gin indexes` for composite data type (`JSON, array ...`).

```sql
CREATE INDEX ON json USING gin(j);
```

> The more complex it gets the harder it is to make it efficient with `JSON`.

#### gist indexes

Use `gist indexes` for geometry data type (`point (10,20);`).

```sql
CREATE TABLE reservation (id bigint PRIMARY KEY, name text NOT NULL, res tsrange NOT NULL);
CREATE INDEX on reservation USING gist (res);
EXPLAIN SELECT * FROM reservation WHERE res && '[2020-04-24 09:00:00,2020-04-24 12:00:00]';
```

#### Regular expressions

When working with regular expressions you should use a `gin_trgm_ops` index.

```sql
CREATE EXTENSION pg_trgm;

CREATE INDEX ON test USING gin (name gin_trgm_ops);

EXPLAIN SELECT * FROM test WHERE name % 'maxime';

EXPLAIN SELECT * FROM test WHERE name ~ 'ma(x)';

SELECT show_trgm('maxime');
{"  m"," ma",axi,ime,max,"me ",xim}
```

#### Tips

- Always use `bigint` by default
- Use `text` if your application **does not** enforce any limit
- Never use `string` to store a `date` or a `number`
- Always test what happens with `NULL` values
- `IS NULL` is the way to test for `NULL` values
- Whenever you create a foreign key always create an index with it.

> Sometimes you have to change the query to make it efficient.

## Day 2 - Transactions and locking; Functions / Json /Partitioning

A transaction is either **completed** or not.

By default `pg` has an auto commit mode which means Each SQL statement is ran in a transaction.

- `A: Atomicity`
- `C: Consistency`
- `I: Isolation`
- `D: Durability`

Any errors that happen within a transaction **abort** the transaction.

```sql
/* COMPLETE A TRANSACTION */
BEGIN;
COMMIT;

/* ROLLBACK A TRANSACTION */
BEGIN;
ROLLBACK;
```

We can prevent this behavior by using a `SAVEPOINT`. This will create a sub transaction to prevent the transaction to abort. This has a performance cost so careful with those.

```sql
SAVEPOINT a;
SELECT 1/0;
ERROR:  division by zero
SELECT 42;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
ROLLBACK TO SAVEPOINT a;
```

By default, waiting for lock is infinite, you can modify it with:

- `SET lock_timeout = '3s';`

### Pessimist locking

The row is **always** locked.

If conflicts happen often prefer the pessimist locking strategy.

```sql
/* This will lock all columns for all tables updated */
SELECT amount FROM account WHERE id = 2 FOR UPDATE;

/* Lock only the account table */
SELECT amount FROM account WHERE id = 2 FOR UPDATE OF account;

/* Do not wait and throw an error */
SELECT amount FROM account WHERE id = 2 FOR UPDATE NOWAIT;
ERROR:  could not obtain lock on row in relation "account"

/* Skip */
SELECT amount FROM account WHERE id = 2 FOR UPDATE SKIP LOCKED;
```

### Optimist locking

We don't lock the row right away. We need to run the transaction again.

If conflicts happen sometimes use the optimist locking strategy.

```sql
BEGIN ISOLATION LEVEL REPEATABLE READ;
```

### Debugging

```sql
/* How pg persist the data internally */
SELECT ctid, xmin, xmax, * FROM account;

BEGIN;
TRUNCATE account;
SELECT pg_backend_pid();
SELECT * FROM pg_locks WHERE pid = 3419;
```

### Deadlock

It's okay to have some deadlocks, we can live with them. Adjust your design and implement rules around them.

### Function

You can create functions in `pg`:

```sql
CREATE FUNCTION doubleme(i integer) RETURNS integer LANGUAGE sql AS 'SELECT i * 2';
SELECT doubleme(21);

CREATE FUNCTION another (IN i integer, OUT x integer, OUT y integer) RETURNS record LANGUAGE sql AS 'SELECT i, i+5';
SELECT another(2);

CREATE FUNCTION tabf (IN i integer, OUT x integer, OUT y integer) RETURNS SETOF record LANGUAGE sql AS 'SELECT i, j FROM generate_series(1, i) AS j';
SELECT * FROM tabf(5);
```

### Tips

- [Locking documentation](https://www.postgresql.org/docs/12/explicit-locking.html)
- Locks affect concurrency
- Readers never block writers and writers never block readers
- Repeatable ensures the consistency of the data.

> Short transactions are the key to database hapiness.

## Day 3 - The PostgreSQL I/O system; Memory management

## Day 4 - Security

## Day 5 - Execution plans / Internal optimization; Ruby on Rails ActiveRecord with PostgreSQL (RAW SQL)

### Links

- [SQL Zine](https://wizardzines.com/zines/sql/)
- [Documentation](https://www.postgresql.org/docs/12/index.html)
- [Cybertec](https://www.cybertec-postgresql.com/en/)
